# ================================================================
# Simple GraphQL-backed Todo App (HTML + Forms + POST/Redirect/GET)
# ================================================================

# ------------------------------------------------
# Config
# ------------------------------------------------

config pg {
  host: $WP_PG_HOST || "localhost"
  port: $WP_PG_PORT || "5432"
  database: $WP_PG_DATABASE || "express-test"
  user: $WP_PG_USER || "postgres"
  password: $WP_PG_PASSWORD || "postgres"
  ssl: false
  initialPoolSize: 10
  maxPoolSize: 20
}

config auth {
  sessionTtl: 604800
  cookieName: "wp_session"
  cookieSecure: false
  cookieHttpOnly: true
  cookieSameSite: "Lax"
  cookiePath: "/"
}

config log {
  enabled: true
  format: "json"
  level: "debug"
  includeBody: false
  includeHeaders: true
  maxBodySize: 1024
  timestamp: true
}

# ------------------------------------------------
# GraphQL Schema for Todos (internal only)
# ------------------------------------------------

graphqlSchema = `
  type Todo {
    id: ID!
    title: String!
    completed: Boolean!
    userId: Int!
    createdAt: String!
    updatedAt: String!
  }

  type Query {
    todos(userId: Int!): [Todo!]!
  }

  type Mutation {
    createTodo(userId: Int!, title: String!): Todo!
    toggleTodo(userId: Int!, id: ID!): Todo!
    deleteTodo(userId: Int!, id: ID!): Boolean!
  }
`

# ------------------------------------------------
# GraphQL Resolvers (DB-backed)
# ------------------------------------------------

# Query: fetch all todos for a user
query todos =
  |> jq: `{ sqlParams: [ .userId ] }`
  |> pg: `
    SELECT
      id,
      title,
      completed,
      user_id AS "userId",
      created_at AS "createdAt",
      updated_at AS "updatedAt"
    FROM todos
    WHERE user_id = $1
    ORDER BY created_at DESC
  `
  |> jq: `.data.rows`

# Mutation: create a todo
mutation createTodo =
  |> jq: `{ sqlParams: [ .title, .userId ] }`
  |> pg: `
    INSERT INTO todos (title, completed, user_id)
    VALUES ($1, false, $2)
    RETURNING
      id,
      title,
      completed,
      user_id AS "userId",
      created_at AS "createdAt",
      updated_at AS "updatedAt"
  `
  |> jq: `.data.rows[0]`

# Mutation: toggle completion flag
mutation toggleTodo =
  |> jq: `{ sqlParams: [ .id, .userId ] }`
  |> pg: `
    UPDATE todos
    SET completed = NOT completed,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = $1 AND user_id = $2
    RETURNING
      id,
      title,
      completed,
      user_id AS "userId",
      created_at AS "createdAt",
      updated_at AS "updatedAt"
  `
  |> jq: `.data.rows[0]`

# Mutation: delete a todo
mutation deleteTodo =
  |> jq: `{ sqlParams: [ .id, .userId ] }`
  |> pg: `DELETE FROM todos WHERE id = $1 AND user_id = $2`
  |> jq: `true`

# ------------------------------------------------
# Helper Pipelines
# ------------------------------------------------

# Derive a userId from header for local dev
# If x-user-id is not present, default to user 1
pipeline withUserIdFromHeader =
  |> jq: `. + {
    userId: ((.headers["x-user-id"] // "1") | tonumber)
  }`

# HTML template for the Todo page
pipeline todoPageTemplate =
  |> handlebars: `
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8" />
        <title>Simple Todo App</title>
        <style>
          body { font-family: system-ui, sans-serif; margin: 2rem; }
          h1 { margin-bottom: 1rem; }
          form { margin-bottom: 1rem; }
          .todo-list { list-style: none; padding: 0; }
          .todo-item { margin: 0.5rem 0; }
          .todo-item.completed .title { text-decoration: line-through; color: #666; }
          .todo-item form { display: inline; margin-left: 0.5rem; }
        </style>
      </head>
      <body>
        <h1>Todos</h1>

        <form method="POST" action="/todos">
          <input
            type="text"
            name="title"
            placeholder="New todo"
            required
            minlength="1"
          />
          <button type="submit">Add</button>
        </form>

        <ul class="todo-list">
          {{#each todos}}
            {{> todoItemPartial}}
          {{/each}}
        </ul>
      </body>
    </html>
  `

# ------------------------------------------------
# Handlebars Partials
# ------------------------------------------------

handlebars todoItemPartial = `
<li class="todo-item {{#if completed}}completed{{/if}}">
  <span class="title">{{title}}</span>
  <form method="POST" action="/todos/{{id}}/toggle">
    <button type="submit">
      {{#if completed}}Mark incomplete{{else}}Mark complete{{/if}}
    </button>
  </form>
  <form method="POST" action="/todos/{{id}}/delete">
    <button type="submit">Delete</button>
  </form>
</li>
`

# ================================================================
# Public HTTP Endpoints (HTML + Forms, backed by GraphQL)
# ================================================================

# GET /todos - render HTML page with current user's todos
GET /todos
  # |> log: `level: debug`
  |> pipeline: withUserIdFromHeader
  |> jq: `.graphqlParams = { userId: .userId }`
  |> graphql: `
    query($userId: Int!) {
      todos(userId: $userId) {
        id
        title
        completed
        userId
        createdAt
        updatedAt
      }
    }
  `
  |> jq: `{ todos: .data.todos }`
  |> pipeline: todoPageTemplate

# POST /todos - create a new todo from form, then re-render page
# (This one still returns HTML; URL stays /todos, which is fine.)
POST /todos
  |> log: `level: debug`
  |> pipeline: withUserIdFromHeader
  |> validate: `
    title: string(1..100)
  `
  |> jq: `.graphqlParams = {
    userId: .userId,
    title: .body.title
  }`
  |> graphql: `
    mutation($userId: Int!, $title: String!) {
      createTodo(userId: $userId, title: $title) {
        id
      }
    }
  `
  # Re-fetch todos and render the full page again
  |> jq: `.graphqlParams = { userId: .graphqlParams.userId }`
  |> graphql: `
    query($userId: Int!) {
      todos(userId: $userId) {
        id
        title
        completed
        userId
        createdAt
        updatedAt
      }
    }
  `
  |> result
    ok(303):
      |> jq: `{ setHeaders: { "Location": "/todos" } }`

# POST /todos/:id/toggle - toggle completion, then redirect to /todos
POST /todos/:id/toggle
  |> log: `level: debug`
  |> pipeline: withUserIdFromHeader
  |> jq: `.graphqlParams = {
    userId: .userId,
    id: (.params.id | tonumber)
  }`
  |> graphql: `
    mutation($userId: Int!, $id: ID!) {
      toggleTodo(userId: $userId, id: $id) {
        id
      }
    }
  `
  |> result
    ok(303):
      |> jq: `{ setHeaders: { "Location": "/todos" } }`

# POST /todos/:id/delete - delete todo, then redirect to /todos
POST /todos/:id/delete
  |> log: `level: debug`
  |> pipeline: withUserIdFromHeader
  |> jq: `.graphqlParams = {
    userId: .userId,
    id: (.params.id | tonumber)
  }`
  |> graphql: `
    mutation($userId: Int!, $id: ID!) {
      deleteTodo(userId: $userId, id: $id)
    }
  `
  |> result
    ok(303):
      |> jq: `{ setHeaders: { "Location": "/todos" } }`

# Optional: tiny home route that links to /todos
GET /
  |> handlebars: `
    <!DOCTYPE html>
    <html>
      <head><title>Home</title></head>
      <body>
        <h1>Home</h1>
        <p><a href="/todos">Go to Todo App</a></p>
      </body>
    </html>
  `

# ================================================================
# Tests
# ================================================================

# ------------------------------------------------
# Template / Pipeline unit test (like teamTemplate)
# ------------------------------------------------

describe "todoPageTemplate pipeline"
  it "renders todos into HTML"
    let todoTitle = "Pipeline todo"

    when executing pipeline todoPageTemplate
    with input `{
      todos: [
        { id: 1, title: $todoTitle, completed: false }
      ]
    }`
    then selector `.todo-list` exists
    and selector `.todo-item` exists
    and selector `.todo-item .title` text equals "{{todoTitle}}"
    and selector `form[action="/todos/1/toggle"]` exists
    and selector `form[action="/todos/1/delete"]` exists

# ------------------------------------------------
# HTML Page Rendering (GraphQL mocked)
# ------------------------------------------------

describe "Simple Todo App - HTML list"
  let userId = 1

  with mock query todos returning `[
    {
      id: 1,
      title: "First todo",
      completed: false,
      userId: $userId,
      createdAt: "2024-01-01T00:00:00Z",
      updatedAt: "2024-01-01T00:00:00Z"
    },
    {
      id: 2,
      title: "Second todo",
      completed: true,
      userId: $userId,
      createdAt: "2024-01-02T00:00:00Z",
      updatedAt: "2024-01-02T00:00:00Z"
    }
  ]`

  it "renders todos with forms using GraphQL behind the scenes"
    when calling GET /todos
    with headers `{
      "x-user-id": ($userId | tostring)
    }`
    then status is 200
    and selector `form[action="/todos"]` exists
    and selector `input[name="title"]` exists
    and selector `.todo-list > .todo-item` count equals 2
    and selector `.todo-list > .todo-item:nth-child(1) .title` text equals "First todo"
    and selector `.todo-list > .todo-item:nth-child(1) form[action="/todos/1/toggle"]` exists
    and selector `.todo-list > .todo-item:nth-child(1) form[action="/todos/1/delete"]` exists
    and selector `.todo-list > .todo-item:nth-child(2)` exists
    and selector `.todo-list > .todo-item:nth-child(2) .title` text equals "Second todo"
    and call query todos with `{
      userId: $userId
    }`

# ------------------------------------------------
# HTML Mutations (POST forms) using GraphQL mocks
# ------------------------------------------------

describe "Simple Todo App - HTML mutations via forms"
  let userId = 2
  let newTitle = "New todo from form"
  let todoId = 5

  with mock mutation createTodo returning `{
    id: 10,
    title: $newTitle,
    completed: false,
    userId: $userId,
    createdAt: "2024-01-02T00:00:00Z",
    updatedAt: "2024-01-02T00:00:00Z"
  }`

  with mock mutation toggleTodo returning `{
    id: 10,
    title: "Example toggled",
    completed: true,
    userId: $userId,
    createdAt: "2024-01-01T00:00:00Z",
    updatedAt: "2024-01-03T00:00:00Z"
  }`

  with mock mutation deleteTodo returning `true`

  # When createTodo completes, the app re-fetches todos via query todos
  with mock query todos returning `[
    {
      id: $todoId,
      title: "Example toggled",
      completed: true,
      userId: $userId,
      createdAt: "2024-01-01T00:00:00Z",
      updatedAt: "2024-01-03T00:00:00Z"
    }
  ]`

  it "creates a todo using POST /todos and re-renders page"
    when calling POST /todos
    with headers `{
      "x-user-id": ($userId | tostring),
      "content-type": "application/json"
    }`
    and with body `{
      title: $newTitle
    }`
    then status is 303
    and call mutation createTodo with `{
      userId: $userId,
      title: $newTitle
    }`

  it "toggles a todo using POST /todos/:id/toggle and redirects to /todos"
    when calling POST /todos/{{todoId}}/toggle
    with headers `{
      "x-user-id": ($userId | tostring),
      "content-type": "application/json"
    }`
    then status is 303
    and call mutation toggleTodo with `{
      userId: $userId,
      id: $todoId
    }`

  it "deletes a todo using POST /todos/:id/delete and redirects to /todos"
    when calling POST /todos/{{todoId}}/delete
    with headers `{
      "x-user-id": ($userId | tostring),
      "content-type": "application/json"
    }`
    then status is 303
    and call mutation deleteTodo with `{
      userId: $userId,
      id: $todoId
    }`
